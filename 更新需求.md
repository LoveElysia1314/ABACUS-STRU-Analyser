# ABACUS-STRU-Analyser 主成分分析（PCA）功能开发指引

## 目标

本指引旨在帮助开发者将PCA降维功能集成到ABACUS-STRU-Analyser项目中，实现如下目标：

1. **所有分析、计算、采样均基于PCA降维后的空间进行。**
2. **PCA降维维数K由命令行参数指定，默认3。**
3. **每帧的K个主成分分量输出到csv，便于后续可视化。**
4. **PCA降维功能强制启用，无开关。**
5. **若原始向量维度n < K，则n+1到K分量补零。**

---

## 主要修改点

### 1. 命令行参数支持

- 在 `main_abacus_analyzer.py` 的 `_parse_arguments` 方法中添加：
  ```python
  parser.add_argument('--pca_components', type=int, default=3, help='PCA降维后的主成分数量 (默认: 3)')
  ```

- 在创建 `SystemAnalyzer` 实例时，传递 `pca_components=args.pca_components`。

- 并行分析相关的 `_worker_analyze_system`、`_child_init`、`_child_worker` 也需增加 `pca_components` 参数传递。

---

### 2. SystemAnalyzer 类修改

- 在 `src/core/system_analyzer.py` 的 `__init__` 方法中增加 `pca_components` 参数，并保存为实例变量。

- 在 `analyze_system` 方法中：
  1. 计算原子间距离向量矩阵后，立即调用 `_apply_pca_reduction` 方法进行降维。
  2. 后续所有指标计算、采样均基于降维后的矩阵。

- 新增 `_apply_pca_reduction` 方法，逻辑如下：
  - 使用 `sklearn.decomposition.PCA`，主成分数为 `min(K, n)`。
  - 若 `n < K`，则补零到K维。
  - 返回降维后的矩阵和PCA模型。

- 新增 `_extract_pca_components` 方法，将每帧的K个主成分分量提取为字典列表，便于后续保存。

- 新增 `_compute_metrics_on_pca_space`、`_sample_on_pca_space` 方法，分别在PCA空间中计算指标和采样。

---

### 3. 结果保存

- 在 `src/io/result_saver.py` 的 `save_results` 方法中，增加保存PCA分量的逻辑：
  - 遍历所有分析结果，将每帧的K个主成分分量写入 `pca_components.csv`。
  - 建议每行包含：system、frame、PC1、PC2、...、PCK。

- 可选：保存PCA模型的解释方差等信息到 `pca_info.json`。

---

### 4. 兼容性与异常处理

- 若 `sklearn` 不可用，程序应直接报错并提示安装。
- 若原始维度小于K，自动补零，保证输出格式一致。
- 所有分析流程均不再使用原始高维空间。

---

## 代码量与开发建议

- 预计新增/修改代码量：200~250行。
- 推荐先在单体系分析流程中实现和测试，再推广到批量与并行流程。
- 建议为PCA相关方法编写单元测试，确保降维和补零逻辑正确。
- 文档和README需同步更新，说明分析流程已基于PCA空间。

---

## 示例流程

1. 用户运行主程序：
   ```
   python main_abacus_analyzer.py --pca_components 5
   ```
2. 程序自动在每个体系分析时，先对所有帧的距离向量做PCA降维（如K=5）。
3. 后续所有指标计算、采样、相关性分析均在降维空间进行。
4. 每帧的5个主成分分量输出到 `pca_components.csv`，便于可视化。

---

## 参考实现片段

```python
# PCA降维
from sklearn.decomposition import PCA
def _apply_pca_reduction(self, vector_matrix):
    n_features = vector_matrix.shape[1]
    actual_components = min(self.pca_components, n_features)
    pca = PCA(n_components=actual_components, random_state=42)
    reduced = pca.fit_transform(vector_matrix)
    if actual_components < self.pca_components:
        padding = np.zeros((reduced.shape[0], self.pca_components - actual_components))
        reduced = np.concatenate([reduced, padding], axis=1)
    return reduced, pca
```

---

## 总结

本指引覆盖了PCA集成的全部关键点。严格按照本指引修改后，项目将实现所有分析流程基于PCA空间，且输出可视化友好的主成分数据。